var documenterSearchIndex = {"docs":
[{"location":"gpu-support/","page":"GPU support","title":"GPU support","text":"note: Disclaimer\nGPGPU is one of the most unportable corners in the programming world. Although I did make use of OpenCL in this package, drivers for graphics cards are problematic and vendors such as NVIDIA do not officially support widely known operating systems.","category":"page"},{"location":"gpu-support/","page":"GPU support","title":"GPU support","text":"warning: GPU option temporarily unavailable\nUpdates in Julia > v1.0 require a major update in the GPU option, see issue #16.","category":"page"},{"location":"gpu-support/","page":"GPU support","title":"GPU support","text":"Two external dependencies need to be manually installed:","category":"page"},{"location":"gpu-support/","page":"GPU support","title":"GPU support","text":"OpenCL driver\nclFFT C++ library","category":"page"},{"location":"gpu-support/#Installing-OpenCL-driver","page":"GPU support","title":"Installing OpenCL driver","text":"","category":"section"},{"location":"gpu-support/","page":"GPU support","title":"GPU support","text":"The choice of the OpenCL driver is dependent on the graphics card you have. Find what is the model of your graphics card and download the appropriate driver from the links below:","category":"page"},{"location":"gpu-support/","page":"GPU support","title":"GPU support","text":"Intel\nAMD\nNVIDIA","category":"page"},{"location":"gpu-support/","page":"GPU support","title":"GPU support","text":"If you are on Linux like myself, check the repositories of your distribution for a more straightforward installation. If you have a recent Intel graphics card, consider the open source Beignet driver also available in some distributions (e.g. AUR repos in Arch Linux).","category":"page"},{"location":"gpu-support/","page":"GPU support","title":"GPU support","text":"To make sure that everything is working properly, install the OpenCL.jl package in Julia and run the tests:","category":"page"},{"location":"gpu-support/","page":"GPU support","title":"GPU support","text":"] add OpenCL\n] test OpenCL","category":"page"},{"location":"gpu-support/","page":"GPU support","title":"GPU support","text":"If the tests are successful, proceed to the next section.","category":"page"},{"location":"gpu-support/#Installing-clFFT-C-library","page":"GPU support","title":"Installing clFFT C++ library","text":"","category":"section"},{"location":"gpu-support/","page":"GPU support","title":"GPU support","text":"Download and install the pre-built binaries. If you are on Linux, you can also check the repositories of your distribution.","category":"page"},{"location":"gpu-support/","page":"GPU support","title":"GPU support","text":"Install the CLFFT.jl package in Julia and run the tests:","category":"page"},{"location":"gpu-support/","page":"GPU support","title":"GPU support","text":"] add CLFFT\n] test CLFFT","category":"page"},{"location":"gpu-support/","page":"GPU support","title":"GPU support","text":"If the tests are successful, the installation is complete.","category":"page"},{"location":"gpu-support/#Testing-GPU-implementation","page":"GPU support","title":"Testing GPU implementation","text":"","category":"section"},{"location":"gpu-support/","page":"GPU support","title":"GPU support","text":"Run the tests to make sure that the GPU implementation is working as expected:","category":"page"},{"location":"gpu-support/","page":"GPU support","title":"GPU support","text":"] test ImageQuilting","category":"page"},{"location":"gpu-support/","page":"GPU support","title":"GPU support","text":"Pass in the option gpu=true to iqsim for computations with the GPU.","category":"page"},{"location":"about/license/","page":"License","title":"License","text":"The ImageQuilting.jl package is licensed under the MIT License:","category":"page"},{"location":"about/license/","page":"License","title":"License","text":"MIT License\n\nCopyright (c) 2015 Júlio Hoffimann <julio.hoffimann@gmail.com> and contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.","category":"page"},{"location":"examples/#Basic","page":"Examples","title":"Basic","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"An example of unconditional simulation (i.e. simulation without data). This is the original Efros-Freeman algorithm for texture synthesis with a few additional options.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using GeoStats\nusing ImageQuilting\nusing GeoStatsImages\nusing Plots\ngr(size=(850,300)) # hide\n\nproblem = SimulationProblem(CartesianGrid(200,200), :facies => Int, 3)\n\nsolver = IQ(\n    :facies => (\n        trainimg = geostatsimage(\"Strebelle\"),\n        tilesize = (62,62)\n    )\n)\n\nsolution = solve(problem, solver)\n\nplot(solution)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"problem = SimulationProblem(CartesianGrid(200,200), :Z => Int, 3)\n\nsolver = IQ(\n    :Z => (\n        trainimg = geostatsimage(\"StoneWall\"),\n        tilesize = (13,13)\n    )\n)\n\nsolution = solve(problem, solver)\n\nplot(solution)","category":"page"},{"location":"examples/#Hard-data","page":"Examples","title":"Hard data","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Hard data (i.e. point data) can be honored during simulation.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"trainimg = geostatsimage(\"Strebelle\")\nobserved = sample(trainimg, 20, replace=false)\n\nproblem = SimulationProblem(observed, domain(trainimg), :facies, 3)\n\nsolver = IQ(\n    :facies => (\n        trainimg = trainimg,\n        tilesize = (30,30)\n    )\n)\n\nsolution = solve(problem, solver)\n\nplot(solution)","category":"page"},{"location":"examples/#Masked-grids","page":"Examples","title":"Masked grids","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Voxels marked with the special symbol NaN are treated as inactive. The algorithm will skip tiles that only contain inactive voxels to save computation and will generate realizations that are consistent with the mask. This is particularly useful with complex 3D models that have large inactive portions.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"trainimg = geostatsimage(\"Strebelle\")\n\n# skip circle at the center\nnx, ny = size(domain(trainimg))\nr = 100; circle = []\nfor i=1:nx, j=1:ny\n    if (i-nx÷2)^2 + (j-ny÷2)^2 < r^2\n        push!(circle, CartesianIndex(i,j))\n    end\nend\n\nproblem = SimulationProblem(domain(trainimg), :facies => Float64, 3)\n\nsolver = IQ(\n    :facies => (\n        trainimg = trainimg,\n        tilesize = (62,62),\n        inactive = circle\n    )\n)\n\nsolution = solve(problem, solver)\n\nplot(solution)","category":"page"},{"location":"examples/#Soft-data","page":"Examples","title":"Soft data","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"It is possible to incorporate auxiliary variables to guide the selection of patterns from the training image.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using ImageFiltering\n\n# image assumed as ground truth (unknown)\ntruthimg = geostatsimage(\"WalkerLakeTruth\")\n\n# training image with similar patterns\ntrainimg = geostatsimage(\"WalkerLake\")\n\nplot(plot(trainimg), plot(truthimg))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# forward model (blur filter)\nfunction forward(data)\n    img = asarray(data, :Z)\n    krn = KernelFactors.IIRGaussian([10,10])\n    fwd = imfilter(img, krn)\n    georef((fwd=fwd,), domain(data))\nend\n\n# apply forward model to both images\ndata   = forward(truthimg)\ndataTI = forward(trainimg)\n\nplot(plot(dataTI), plot(data))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# simulate patterns over the domain of interest\nproblem = SimulationProblem(domain(truthimg), :Z => Float64, 3)\n\nsolver = IQ(\n    :Z => (\n        trainimg = trainimg,\n        tilesize = (27,27),\n        soft = (data,dataTI)\n    )\n)\n\nsolution = solve(problem, solver)\n\nplot(solution)","category":"page"},{"location":"voxel-reuse/#Helper-function","page":"Voxel reuse","title":"Helper function","text":"","category":"section"},{"location":"voxel-reuse/","page":"Voxel reuse","title":"Voxel reuse","text":"A helper function is provided for the fast approximation of the mean voxel reuse:","category":"page"},{"location":"voxel-reuse/","page":"Voxel reuse","title":"Voxel reuse","text":"voxelreuse","category":"page"},{"location":"voxel-reuse/#ImageQuilting.voxelreuse","page":"Voxel reuse","title":"ImageQuilting.voxelreuse","text":"voxelreuse(trainimg::AbstractArray{T,N}, tilesize::Dims{N};\n           overlap::NTuple{N,Float64}=ntuple(i->1/6,N),\n           nreal::Integer=10, kwargs...)\n\nReturns the mean voxel reuse in [0,1] and its standard deviation.\n\nNotes\n\nThe approximation gets better as nreal is made larger.\nKeyword arguments kwargs are passed to iqsim directly.\n\n\n\n\n\n","category":"function"},{"location":"voxel-reuse/#Plot-recipe","page":"Voxel reuse","title":"Plot recipe","text":"","category":"section"},{"location":"voxel-reuse/","page":"Voxel reuse","title":"Voxel reuse","text":"A plot recipe is provided for tile design in image quilting. In order to plot the voxel reuse of a training image, install Plots.jl and any of its supported backends (e.g. GR.jl):","category":"page"},{"location":"voxel-reuse/","page":"Voxel reuse","title":"Voxel reuse","text":"] add Plots","category":"page"},{"location":"voxel-reuse/","page":"Voxel reuse","title":"Voxel reuse","text":"The example below uses training images from the GeoStatsImages.jl package:","category":"page"},{"location":"voxel-reuse/","page":"Voxel reuse","title":"Voxel reuse","text":"using ImageQuilting\nusing GeoStatsImages\nusing Plots\n\nTI₁ = geostatsimage(\"Strebelle\")\nTI₂ = geostatsimage(\"StoneWall\")\n\nvoxelreuseplot(TI₁, label=\"Strebelle\")\nvoxelreuseplot!(TI₂, label=\"StoneWall\")","category":"page"},{"location":"voxel-reuse/","page":"Voxel reuse","title":"Voxel reuse","text":"(Image: Voxel reuse plot)","category":"page"},{"location":"about/author/","page":"Author","title":"Author","text":"Júlio Hoffimann","category":"page"},{"location":"about/author/","page":"Author","title":"Author","text":"You can find more about my research on my website.","category":"page"},{"location":"about/author/","page":"Author","title":"Author","text":"Below are some ways that we can connect:","category":"page"},{"location":"about/author/","page":"Author","title":"Author","text":"ResearchGate\nLinkedIn\nGitHub","category":"page"},{"location":"about/citation/","page":"Citation","title":"Citation","text":"If you find ImageQuilting.jl useful in your work, please consider citing our paper:","category":"page"},{"location":"about/citation/","page":"Citation","title":"Citation","text":"@ARTICLE{Hoffimann2017,\n  title={Stochastic Simulation by Image Quilting of Process-based Geological Models},\n  author={Hoffimann, J{\\'u}lio and Scheidt, C{\\'e}line and Barfod, Adrian and Caers, Jef},\n  journal={Computers \\& Geosciences},\n  publisher={Elsevier BV},\n  volume={106},\n  pages={18-32},\n  ISSN={0098-3004},\n  DOI={10.1016/j.cageo.2017.05.012},\n  url={http://dx.doi.org/10.1016/j.cageo.2017.05.012},\n  year={2017},\n  month={May}\n}","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for fast 3D image quilting simulation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Coverage Status) (Image: Stable Documentation) (Image: Latest Documentation)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package implements an extension to the famous Efros-Freeman algorithm for texture synthesis and transfer in computer vision. Unlike the original algorithm developed for 2D images, our method can also handle 3D masked grids and pre-existing point-data very efficiently (the fastest in the literature). For more details, please refer to our paper in Citation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: 3D Quilting Animation)","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Masked grids\nHard data conditioning\nSoft data conditioning\nFast computation with GPUs","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Get the latest stable release with Julia's package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add ImageQuilting","category":"page"},{"location":"","page":"Home","title":"Home","text":"For even faster computation with GPUs, please follow the instructions in GPU support.","category":"page"},{"location":"#Talks","page":"Home","title":"Talks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Below is a list of talks related to this project. For more material, please subscribe to the YouTube channel.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<p align=\"center\">\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/YJs7jl_Y9yM\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</p>\n<p align=\"center\">\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/Y5KhQCapuPw\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</p>","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is part of the GeoStats.jl framework. Solver options are displayed below:","category":"page"},{"location":"","page":"Home","title":"Home","text":"IQ","category":"page"},{"location":"#ImageQuilting.IQ","page":"Home","title":"ImageQuilting.IQ","text":"IQ(var₁=>param₁, var₂=>param₂, ...)\n\nImage quilting simulation solver as described in Hoffimann et al. 2017.\n\nParameters\n\nRequired\n\ntrainimg - Training image from which to extract tiles\ntilesize - Tuple with tile size for each dimension\n\nOptional\n\noverlap  - Overlap size (default to (1/6, 1/6, ..., 1/6))\npath     - Simulation path (:raster (default), :dilation, or :random)\nmapping  - Data mapping method (default to NearestMapping())\ninactive - Vector of inactive voxels (i.e. CartesianIndex) in the grid\nsoft     - A pair (data,dataTI) of geospatial data objects (default to nothing)\ntol      - Initial relaxation tolerance in (0,1] (default to 0.1)\n\nGlobal parameters\n\nOptional\n\nthreads      - Number of threads in FFT (default to number of physical CPU cores)\nshowprogress - Whether to show or not the estimated time duration (default to false)\nrng          - Random number generator (default to Random.GLOBAL_RNG)\n\nReferences\n\nHoffimann et al 2017. Stochastic simulation by image quilting of process-based geological models.\nHoffimann et al 2015. Geostatistical modeling of evolving landscapes by means of image quilting.\n\n\n\n\n\n\n\n","category":"type"},{"location":"#Low-level-API","page":"Home","title":"Low-level API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you are interested in using the package without GeoStats.jl, please use the following function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"iqsim","category":"page"},{"location":"#ImageQuilting.iqsim","page":"Home","title":"ImageQuilting.iqsim","text":"iqsim(trainimg::AbstractArray{T,N}, tilesize::Dims{N},\n      simsize::Dims{N}=size(trainimg);\n      overlap::NTuple{N,<:Real}=ntuple(i->1/6,N),\n      soft::AbstractVector=[], hard::Dict=Dict(), tol::Real=.1,\n      path::Symbol=:raster, nreal::Integer=1,\n      threads::Integer=cpucores(), debug::Bool=false,\n      showprogress::Bool=false, rng::AbstractRNG=Random.GLOBAL_RNG)\n\nPerforms image quilting simulation as described in Hoffimann et al. 2017.\n\nParameters\n\nRequired\n\ntrainimg is any Julia array\ntilesize is the tile size\n\nOptional\n\nsimsize is the size of the simulation grid (default to training image size)\noverlap is the percentage of overlap (default to 1/6 of tile size)\nsoft is a vector of (data,dataTI) pairs (default to none)\nhard is a dictionary mapping coordinates to data values (default to none)\ntol is the initial relaxation tolerance in (0,1] (default to .1)\npath is the simulation path (:raster, :dilation or :random)\nnreal is the number of realizations (default to 1)\nthreads is the number of threads for the FFT (default to all CPU cores)\ndebug informs whether to export or not the boundary cuts and voxel reuse\nshowprogress informs whether to show or not estimated time duration\nrng is the random number generator (default to Random.GLOBAL_RNG)\n\nThe main output reals consists of a list of realizations that can be indexed with reals[1], reals[2], ..., reals[nreal]. If debug=true, additional output is generated:\n\nreals, cuts, voxs = iqsim(..., debug=true)\n\ncuts[i] is the boundary cut for reals[i] and voxs[i] is the associated voxel reuse.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"The major difference compared to the high-level API is that the iqsim function has no notion of coordinate system, and you will have to pre-process the data manually to match it with the cells in the simulation grid.","category":"page"},{"location":"","page":"Home","title":"Home","text":"GeoStats.jl takes the coordinate system into account and also enables parallel simulation on HPC clusters.","category":"page"}]
}
